---
title: "P8105 Data Science I Homework 4"
author: Olivia Wang (hw2852)
output: github_document
date: "2022-11-16"
---

In preparation for the problems below, we will load the following libraries: 

```{r load_libraries}
library(tidyverse)
library(readxl)
library(dplyr)
```

# Problem 1



# Problem 2

Let us begin by importing the CSV file containing _Washington Post's_ homicide data downloaded from GitHub, and applying the `clean_names` function. We can then apply the `skim` function to generate a brief data summary. 

```{r}
homicide_data = 
  read_csv("./homicide-data.csv") %>% 
  janitor::clean_names()

skimr::skim(homicide_data)
```

The _Washington Post's_ raw homicide data contains __`r nrow(homicide_data)` rows__ and __`r ncol(homicide_data)` columns__. Each row corresponds to one homicide case, and the following information regarding the homicide are found in each column:

* Case ID code
* Reported date
* Victim identifiers (name, age, race and sex)
* Location details (state, city, latitude and longitude)
* Disposition

Based on the output generated above, we can see that there are no missing values for all variables except for `latitude` and `longitude`. The `latitude` variable has __`r sum(is.na(homicide_data$lat))` missing values__ and the `longitude` variable has __`r sum(is.na(homicide_data$lon))` missing values__. 

## 2.1 City-Level Summaries of Homicide Data

#### _Total Homicides per City_

In the following code chunk, we create a new `city_state` variable (e.g. "Baltimore, MD") by joining the existing city and state variables using the `paste` command. Since each row represents a unique homicide case, we can determine the total number of homicides by counting the number of observations per city, state pair. 

```{r}
homicide_data = homicide_data %>% 
  mutate(city_state = as.character(paste(city, state, sep = ", ")))

total_homicides =
  homicide_data %>% 
  group_by(city_state) %>% 
  summarize(n_obs = n()) %>% 
  arrange(desc(n_obs))
  
knitr::kable(total_homicides, col.names = c('City, State', 'Total Homicides (n)'))
```

#### _Total Unsolved Homicides per City_

To determine the total number of unsolved homicides per city, we can generate a new binary `unsolved_homicide` variable, which will take on a value of 1 if the homicide is unsolved (i.e., disposition = "Closed without arrest" or "Open/No arrest") and 0 if the homicide is solved (i.e., disposition = "Closed by arrest"). 

```{r}
homicide_data = homicide_data %>% 
  mutate(unsolved_homicide = ifelse(disposition == "Closed by arrest", 0, 1))

unsolved_homicides =
  homicide_data %>% 
  group_by(city_state) %>%
  filter(unsolved_homicide == 1) %>% 
  summarize(n_obs = n()) %>% 
  arrange(desc(n_obs))

knitr::kable(unsolved_homicides, col.names = c('City, State', 'Unsolved Homicides (n)'))
```

## 2.2 City-Level Homicide Porportion Estimates & 95% CIs

#### _Proportion of Unsolved Homicides in Baltimore, MD_

Below we use the `prop.test` function to estimate the proportion of homicides that are unsolved in Baltimore, MD. The arguments for the `prop.test` function, x and n, were determined using the outputs from Problem 2.1. Argument x, a vector of counts of successes, is the number of unsolved homicides in Baltimore, MD, and n, a vector of counts of trials, is the total number of homicides in Baltimore, MD.

The output generated from the `prop.test` function is then saved as an R object. The `broom::tidy()` function was applied to tidy these data, and finally the proportion estimate and the 95% confidence interval values were pulled. 

```{r}
homicide_data %>% 
  filter(city_state == "Baltimore, MD")

prop_test_homicide_baltimore = prop.test(x = 1825, n = 2827, conf.level = 0.95) 

prop_test_homicide_baltimore %>%
  broom::tidy() %>%
  select(estimate, starts_with("conf"))
```

#### _Proportion of Unsolved Homicides in All Cities_

```{r}
homicide_data_to_prop_test = function(homicide_data) {
  prop.test(x = homicide_data$unsolved_homicides, n = homicide_data$total_homicides, conf.level = 0.95) %>%
    broom::tidy() %>% 
    select(estimate, starts_with("conf"))
}

inner_join(rename(total_homicides, total_homicides = n_obs), rename(unsolved_homicides, unsolved_homicides = n_obs)) %>%
  nest(data = total_homicides:unsolved_homicides) %>%
  mutate(data = purrr::map(data, ~ homicide_data_to_prop_test(.x))) %>%
  unnest

```

# Problem 3







